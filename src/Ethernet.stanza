#use-added-syntax(jitx)
defpackage connectors/Ethernet :
  import core
  import collections
  import jitx
  import jitx/commands
  import jsl/symbols/box-symbol
  import jsl/symbols/SymbolDefn
  import jitx/shapes

  import jsl/ensure
  import jsl/landpatterns/packages
  import jsl/landpatterns/VirtualLP
  import jsl/landpatterns/pad-planner
  import jsl/landpatterns/numbering
  import jsl/landpatterns/silkscreen
  import jsl/errors
  import jsl/landpatterns/leads
  import jsl/geometry/LineRectangle
  import jsl/geometry/box
  import jsl/landpatterns/quad
  import jsl/landpatterns/pads
  import jsl/landpatterns/courtyard
  import jsl/design/settings
  import jsl/geometry/basics

val PANEL-CUTOUT-WIDTH = 16.65

val JD0-0001NL-GRID-ROWS = 2
val JD0-0001NL-COLS = 5
val JD0-0001NL-EXTRA = [4]
val JD0-0001NL-GRID-PADS = JD0-0001NL-GRID-ROWS * JD0-0001NL-COLS

val JD0-0001NL-LEAD = tol(3.50, 0.25)
val JD0-0001NL-GRID-LEAD-WIDTH = tol(0.9, 0.08)
val JD0-0001NL-ROW-LEAD-WIDTH = tol(1.2, 0.008)

val JD0-0001NL-ROW-LEAD-DIAM = 1.2
val JD0-0001NL-ROW-LEAD-TOL = 0.008

val JD0-0001NL-LENGTH = 21.35
val JD0-0001NL-WIDTH = 15.90
val JD0-0001NL-HEIGHT = 13.63
val JD0-0001NL-TOL = 0.25
val JD0-0001NL-GRID-SPACING = Dims(2.54, 0.0)

val JD0-0001NL-MED-HOLE-DIAM = 1.60
val JD0-0001NL-LRG-HOLE-DIAM = 3.25

defn default-lead-types () :
  TH-Lead(
    length = JD0-0001NL-LEAD
    width = JD0-0001NL-GRID-LEAD-WIDTH
  )

defn default-numbering () :
  Col-Major-Extra-Rows-Numbering(
   JD0-0001NL-GRID-PADS, JD0-0001NL-GRID-ROWS, JD0-0001NL-EXTRA
  )

defn default-pad-planner () :
  PthPadPlanner( {Circle(to-radius $ x(_))})

defn min-hole-size (max-lead-diam:Double, density:DensityLevel = DensityLevelC) :
  if density == DensityLevelA :
    max-lead-diam + 0.25
  else if density == DensityLevelB :
    max-lead-diam + 0.20
  else :
    max-lead-diam + 0.15

; Pad Diameter = Minimum Hole Size + Minimum Annular Ring X 2 + Minimum Fabrication Allowance
defn min-pad-size (min-hole-size:Double, density:DensityLevel = DensityLevelC) :
  val annular-ring-diam = 2.0 * clearance(current-rules(), MinAnnularRing)
  if density == DensityLevelA :
    min-hole-size + annular-ring-diam + 0.60
  else if density == DensityLevelB :
    min-hole-size + annular-ring-diam + 0.50
  else :
    min-hole-size + annular-ring-diam + 0.40

; Information for creating a grid of pads, as commonly found on connectors
public defstruct PadGridProfile :
  center:Pose
  num-grid-leads:Int
  num-grid-rows:Int
  spacing:Dims
  row-offsets:Tuple<Point> ; length(row-offsets) == num-grid-rows
  lead-type:Lead
with :
  constructor => #PadGridProfile

public defn PadGridProfile (
  --
  center:Pose
  num-grid-leads:Int
  num-grid-rows:Int
  spacing:Dims
  row-offsets:Tuple<Point>
  lead-types:Lead
) :
  #PadGridProfile(
    center,
    num-grid-leads, num-grid-rows,
    spacing,
    row-offsets,
    lead-types
  )

defn default-grid-profile () :
  PadGridProfile(
    center = loc(0.0, 8.89)
    num-grid-leads = JD0-0001NL-GRID-PADS
    num-grid-rows = JD0-0001NL-GRID-ROWS
    spacing = JD0-0001NL-GRID-SPACING
    row-offsets = [
      Point(0.0, 0.0)
      Point(1.27, 6.35 - 8.89)
    ]
    lead-types = default-lead-types()
  )

; Baseline information for creating a row of pads/cutouts
public defstruct RowInfo :
  center: Pose
  num-cols: Int
  spacing: Dims
  mirror-dims: Dims|False
with :
  constructor => #RowInfo
  printer => true

public defn RowInfo (
  --
  center:Pose
  num-cols:Int
  spacing:Dims
  mirror-dims:Dims|False
) :
  #RowInfo(center, num-cols, spacing, mirror-dims)

public defstruct PadRowInfo :
  row-info: RowInfo
  lead-types: Tuple<Lead>|Lead
  hole-width: Dims|False
    with: (default => false)
  pad-width: Dims

public defstruct HoleRowInfo :
  row-info: RowInfo
  hole-shapes: Tuple<Shape>|Shape
with :
  printer => true

defn default-extra-hole-rows () :
 [
  ; Holes for connector shield
  HoleRowInfo(
    RowInfo(
      center = loc(-2.14, 3.05),
      num-cols = 2,
      spacing = Dims(0.0, 0.0)
      mirror-dims = Dims(2.14 + 13.57, 0.0)
    ),
    Circle(Point(0.0, 0.0), JD0-0001NL-MED-HOLE-DIAM / 2.0)
  )
  ; Larger holes for component stabilization
  HoleRowInfo(
    RowInfo(
      center = loc(0.0, 0.0),
      num-cols = 2,
      spacing = Dims(11.43, 0.0)
      mirror-dims = false
    )
    Circle(Point(0.0, 0.0), JD0-0001NL-LRG-HOLE-DIAM / 2.0)
  )
]

defn default-extra-pad-rows () :
  [
    PadRowInfo(
      RowInfo(
        center = loc(-0.93, -4.06),
        num-cols = 2,
        spacing = Dims(1.62 + 0.93, 0.0)
        mirror-dims = Dims(9.82 - 1.62, 0.0)
      )
      TH-Lead(
        length = JD0-0001NL-LEAD
        width = JD0-0001NL-ROW-LEAD-WIDTH
      )
      Dims(1.6, 1.6)
    )
  ]

doc: \<DOC>
<DOC>
public defstruct Ethernet <: Package :
  doc: \<DOC>
  Info for the main grid of leads
  <DOC>
  lead-grid-profile:PadGridProfile

  doc: \<DOC>
  Info for an arbitrary row of leads
  <DOC>
  extra-lead-rows:Tuple<PadRowInfo>
  doc: \<DOC>

  Info for an arbitrary row of holes
  <DOC>
  extra-hole-rows:Tuple<HoleRowInfo>

  doc: \<DOC>

  Package Body for the Quad-based Package.
  <DOC>
  package-body:PackageBody with: (as-method => true)

  doc: \<DOC>
  Pad Planner

  This provides a default pad planner. The user can override this with their preferred
  shape as desired.
  <DOC>
  pad-planner:PadPlanner with: (as-method => true)

  doc: \<DOC>
  Lead Numbering Scheme

  This provides a numbering scheme for the leads.
  By default, it uses {@link Column-Major-Numbering}.
  <DOC>
  lead-numbering:Numbering with: (as-method => true)

  doc: \<DOC>
  Keep-out shapes

  This provides the shape specifications for the keepout regions
  <DOC>
  keep-outs:Tuple<Shape>

with:
  printer => true
  constructor => #Ethernet

public defn Ethernet (
  --
  lead-grid-profile:PadGridProfile = default-grid-profile()
  extra-lead-rows:Tuple<PadRowInfo> = default-extra-pad-rows()
  extra-hole-rows:Tuple<HoleRowInfo> = default-extra-hole-rows()
  package-body:PackageBody = default-package-body()
  pad-planner:PadPlanner = default-pad-planner()
  lead-numbering:Numbering = default-numbering()
  keep-outs:Tuple<Shape> = default-keep-outs()
):
  #Ethernet(
    lead-grid-profile,
    extra-lead-rows, extra-hole-rows,
    package-body, pad-planner, lead-numbering,
    keep-outs
  )

public defstruct GridWithRowsPlanner <: PadPlanner :
  rows:Int
    with : (ensure => ensure-positive!)
  cols:Int
    with : (ensure => ensure-positive!)
  extra-row-cols:Tuple<Int>

public defmethod name (pkg:Ethernet) -> String :
  "EthernetConnector"

public defn build-cutouts (
  pkg:Ethernet
  vp:VirtualLP
  --
  pose:Pose = ?
) -> False:
  inside pcb-landpattern:
    for (hole-row in extra-hole-rows(pkg), i in 0 to false) do :
      val ri = row-info(hole-row)
      val s = spacing(ri)

      defn generate-hole-row-seg (start:Point, mirror?:True|False) :
        for j in 0 to num-cols(ri) do :
          val pos-x = x(start) + x(s) * to-double(j)
          val pos-y = y(start) + y(s) * to-double(j)
          val pos = loc(pos-x, pos-y) * center(ri)
          layer(Cutout()) = transform(pos,
            match(hole-shapes(hole-row)) :
              (s:Shape) : s
              (t:Tuple<Shape>) :
                if mirror? : t[num-cols(ri) - 1 - j]
                else : t[j]
          )

      generate-hole-row-seg(Point(0.0,0.0), false)
      match(mirror-dims(ri)) :
        (d:Dims) :
          val start-x = x(s) * to-double(num-cols(ri) - 1) + x(d)
          val start-y = y(s) * to-double(num-cols(ri) - 1) + y(d)
          generate-hole-row-seg(Point(start-x, start-y), true)
        (f) : false

public defmethod build-courtyard (
  pkg:Ethernet,
  vp:VirtualLP,
) -> False:
  build-courtyard-origin(vp)
  ;val excess = courtyard-excess(pkg)

public defmethod courtyard-excess (pkg:Ethernet) -> Double :
  PANEL-CUTOUT-WIDTH - JD0-0001NL-WIDTH

public defmethod build-silkscreen (
  pkg:Ethernet,
  vp:VirtualLP
  ) -> False:
  Ethernet-outline(pkg, vp)
  Ethernet-pin-1-marker(pkg, vp)

defn default-package-body () :
  PackageBody(
    width = tol(JD0-0001NL-WIDTH, JD0-0001NL-TOL)
    length = tol(JD0-0001NL-LENGTH, JD0-0001NL-TOL)
    height = tol(JD0-0001NL-HEIGHT, JD0-0001NL-TOL)
    pose = loc(2.24, 0.0)
  )

public defn Ethernet-outline (
  pkg:Ethernet
  vp:VirtualLP
  --
  line-width:Double = default-silk-width(),
  mask-clearance:Double = default-mask-clearance(),
  side:Side = Top
) -> False :
  val pkg-body = package-body(pkg)
  val pkg-outline = bounds $ envelope(pkg-body, density-level = density-level(pkg))
  val pkg-outline* = fatten(line-width / 2.0, pkg-outline)
  val outline-geom = LineRectangle(pkg-outline*, line-width = line-width)

  add-artwork(vp, Silkscreen("outline", side), outline-geom, class = "outline")

public defn get-silkscreen-outline! (vp:VirtualLP) -> Shape :
  val outlines = to-tuple $ seq{as-VirtualArtwork, _} $ find-by-class(vp, "outline")
  if length(outlines) != 1:
    throw $ ValueError("Expected only one element in class 'outline': %," % [outlines])

  val outline = outlines[0]
  shape(outline)

; Consolidate into utility function?
public defn Ethernet-pin-1-marker (
  pkg:Ethernet,
  vp:VirtualLP
  --
  pin-1-id:Int|Ref = 1,
  line-width:Double = default-silk-width(),
  mask-clearance:Double = default-mask-clearance(),
  side:Side = Top
  ):

  val extra-margin = 0.0

  val pin-1-pad = get-pad-by-ref!(vp, pin-1-id)

  val pad-loc = pose(pin-1-pad)
  val pad-center = center(pad-loc)

  val smasks = get-layer(pin-1-pad, SolderMask(side))
  if length(smasks) == 0:
    ; This is a very strange error - it means
    ;  that pad 1 of this component doesn't have a soldermask
    ;  opening.
    ; This could happen if the user passed an erroneous `side` argument
    throw $ ValueError("Pin-1 - No Soldermask Opening for Pad on Side: %_" % [side])
  val smask = smasks[0]

  val width = x $ dims(smask)
  val offset = Point((- (width / 2.0) + mask-clearance + line-width + extra-margin), 0.0)
  val marker-shape = Circle(offset, line-width)

  val marker-geom = pad-loc * marker-shape

  add-artwork(vp, Silkscreen("pin-1-marker", side), marker-geom, name = "pin-1-dot", class = "pin1-marker")

  val outline = get-silkscreen-outline!(vp)
  val o-box = bounds(outline)

  val marker = compute-triangle-marker(pad-center, o-box, line-width)
  add-artwork(
    vp, Silkscreen("pin-1-marker", side),
    marker,
    name = "pin-1-triangle",
    class = "pin-1-marker"
    )

public defstruct Col-Major-Extra-Rows-Numbering <: Numbering :
  num-pads:Int with: (ensure => ensure-positive!)
  num-rows:Int with: (ensure => ensure-positive!)
  extra-row-cols:Tuple<Int>
with:
  constructor => #Col-Major-Extra-Rows-Numbering

public defn Col-Major-Extra-Rows-Numbering (
  num-pads:Int,
  num-rows:Int,
  extra-row-cols:Tuple<Int>
) -> Col-Major-Extra-Rows-Numbering :
  ensure-divisible!(num-pads, num-rows, "Col-Major-Extra-Rows-Numbering")
  #Col-Major-Extra-Rows-Numbering(num-pads, num-rows, extra-row-cols)

public defmethod to-pad-id (x:Col-Major-Extra-Rows-Numbering, row:Int, column:Int) -> Int|Ref :
  val rows = num-rows(x)
  val cols = num-pads(x) / rows

  if (row < 0 or column < 0):
    throw $ ValueError("Expecting Non-negative Indices: r=%_ c=%_" % [row,column])

  if (row >= rows):
    val extra-row-idx = row - rows
    if extra-row-idx > length(extra-row-cols(x)) - 1:
      throw $ ValueError("Invalid Row Offset: %_ < %_" % [extra-row-idx, length(extra-row-cols(x))])
    else :
      if not (column < extra-row-cols(x)[extra-row-idx]):
        throw $ ValueError("Invalid Column Offset: %_ < %_" % [column, cols])
      num-pads(x) + extra-row-idx + column + 1
  else :
    if not (column < cols):
      throw $ ValueError("Invalid Column Offset: %_ < %_" % [column, cols])
    (column * rows) + row + 1

public defmethod build-pads (
  pkg:Ethernet,
  vp:VirtualLP,
  ) -> False :
  build-vpads(pkg, vp)
  build-cutouts(pkg, vp)

public defn build-vpads (
  pkg:Ethernet,
  vp:VirtualLP
):
  val grid-prof = lead-grid-profile(pkg)

  ; We call them rows for convenience in the definition
  ;  but for our grid construction - the rows are actually columns
  val rows = num-grid-rows(grid-prof)
  val cols = num-grid-leads(grid-prof) / rows

  ; Generate the grid
  val planner = pad-planner(pkg)
  defn gen-grid-pads () -> Seq<VirtualPad> :
    val min-hole-width = min-hole-size(typ $ width(lead-type(grid-prof)))
    val min-pad-width = min-pad-size(min-hole-width)

    val hole-size = Dims(min-hole-width, min-hole-width)
    val pad-size = Dims(min-pad-width, min-pad-width)
    val s = spacing(grid-prof)
    for (r in 0 to rows) seq-cat :
      for (c in 0 to cols) seq?:
        val pt = row-offsets(grid-prof)[r] + Point(x(s) * to-double(c), y(s) * to-double(r))
        val pos = Pose(pt, 0.0, false) * center(grid-prof)
        val pad-id = to-pad-id(lead-numbering(pkg), r, c)
        val pad-gen? = match(lead-type(grid-prof)):
          (th:TH-Lead):
            val g = th-pad-generator(planner, r, c)
            match(g):
              (_:False): false
              (func): {func(hole-size, _0)}
        match(pad-gen?):
          (_:False): None()
          (pad-gen):
            val cls = [
              "pad",
              to-string("col-%_" % [c]),
              to-string("row-%_" % [r])
            ]
            One $ VirtualPad(pad-id, pad-gen(pad-size), pos, class = cls)

  ; Generate rows
  defn gen-extra-pad-rows () -> Seq<VirtualPad> :
    for (lead-row in extra-lead-rows(pkg),
      r in 0 to false) seq-cat :
      val ri = row-info(lead-row)
      val s = spacing(ri)

      defn gen-pad-row-seg (start:Point, col-offset:Int, length:Int) -> Seq<VirtualPad> :
        for i in 0 to length seq? :
          val pt = Point(x(start) + x(s) * to-double(i), y(start) + y(s) * to-double(i))
          val pos = Pose(pt, 0.0, false) * center(ri)
          val col = col-offset + i
          val pad-id = to-pad-id(lead-numbering(pkg), rows + r, col)
          val lead-type = match(lead-types(lead-row)) :
            (t:Tuple<Lead>) : t[rows * r + col]
            (l:Lead) : l
          val min-hole-width =
            match(hole-width(lead-row)) :
              (d:Dims) :
                x(d)
              (f:False) :
                min-hole-size(typ $ width(lead-type))
          val min-pad-width = min-pad-size(min-hole-width)
          val hole-size = Dims(min-hole-width, min-hole-width)
          val pad-size = Dims(min-pad-width, min-pad-width)

          val pad-gen? = match(lead-type):
            (th:TH-Lead):
              val g = th-pad-generator(planner, rows + r, col)
              match(g):
                (_:False): false
                (func): {func(hole-size, _0)}
          match(pad-gen?):
            (_:False): None()
            (pad-gen):
              val cls = [
                "pad",
                to-string("col-%_" % [col]),
                to-string("extra-row-%_" % [rows + r])
              ]
              println("DEBUG %_ at pos %_" % [pad-id, pos])

              One $ VirtualPad(pad-id, pad-gen(pad-size), pos, class = cls)

      val pads = gen-pad-row-seg(Point(0.0,0.0), 0, num-cols(ri))
      val mirror-pads = match(mirror-dims(ri)) :
        (d:Dims) :
          val scale = to-double $ (num-cols(ri) - 1)
          val start = Point(x(d) + scale * x(s), y(d) + scale * y(s))
          gen-pad-row-seg(start, num-cols(ri), num-cols(ri))
        (f:False) :
          []
      cat(pads, mirror-pads)

  append-all(vp, gen-grid-pads())
  append-all(vp, gen-extra-pad-rows())

public defmethod build-keep-out (
  pkg:Ethernet,
  vp:VirtualLP,
) -> False:
  inside pcb-landpattern :
    for s in keep-outs(pkg) do :
      layer(ForbidCopper(LayerIndex(0), LayerIndex(0, Bottom))) = s

defn default-keep-outs () :
  val secondary-ko-width = 2.24 / 2.0
  [
    transform(loc(Point(-1.29, -10.75)), Rectangle(SW, 12.72 + 1.29, 10.75 - 8.05))
    transform(loc(Point(-2.24, 0.0)), Rectangle(SW, secondary-ko-width, 2.0))
    transform(loc(Point(13.67 - secondary-ko-width, 0.0)), Rectangle(SW, secondary-ko-width, 2.0))
  ]

public pcb-component JD0-0001NL :
  name = "553-2359-ND"
  description = "CONN JACK 1PORT 1000 BASE-T PCB"
  manufacturer = "Pulse Electronics"
  mpn = "JD0-0001NL"
  datasheet = "https://productfinder.pulseelectronics.com/api/open/part-attachments/datasheet/JD0-0001NL"
  reference-prefix = "J"
  pin-properties :
    [pin:Ref | pads:Ref ... | side:Dir]
    [p[1] | p[1] | Left]
    [p[2]| p[2] | Left]
    [p[3] | p[3] | Left]
    [p[4] | p[4] | Left]
    [p[5] | p[5] | Left]
    [p[6] | p[6] | Left]
    [p[7] | p[7] | Left]
    [p[8] | p[8] | Left]
    [p[9] | p[9] | Right]
    [p[10] | p[10] | Right]
    [p[11] | p[11] | Right]
    [p[12] | p[12] | Right]
    [p[13] | p[13] | Right]
    [p[14] | p[14] | Right]

  val pkg = Ethernet()
  val lp = create-landpattern(pkg)

  assign-landpattern(lp)

  val box = BoxSymbol(self)
  assign-symbol(create-symbol $ box)
