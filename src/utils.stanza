#use-added-syntax(jitx)
defpackage connectors/utils :
  import core
  import collections
  import jitx
  import jitx/commands

  import jsl/design/settings
  import jsl/design/Classable

  import jsl/ensure
  import jsl/errors
  import jsl/landpatterns/numbering
  import jsl/landpatterns/VirtualLP
  import jsl/landpatterns/leads/lead-types

public defstruct Column-Major-Numbering-WithOffset <: Numbering :
  num-pads:Int with: (ensure => ensure-positive!)
  num-columns:Int with: (ensure => ensure-positive!)
  offset:Int with: (ensure => ensure-non-negative!)
with:
  constructor => #Column-Major-Numbering-WithOffset

public defn Column-Major-Numbering-WithOffset (
  --
  num-pads:Int,
  num-columns:Int
  offset:Int = 0
) -> Column-Major-Numbering-WithOffset :
  ensure-divisible!(num-pads, num-columns, "Column-Major-Numbering-WithOffset")
  #Column-Major-Numbering-WithOffset(num-pads, num-columns, offset)

public defmethod to-pad-id (x:Column-Major-Numbering-WithOffset, row:Int, column:Int) -> Int|Ref :
  val cols = num-columns(x)
  val rows = num-pads(x) / cols

  if (row < 0 or column < 0):
    throw $ ValueError("Expecting Non-negative Indices: r=%_ c=%_" % [row,column])

  if not (row < rows):
    throw $ ValueError("Invalid Row Offset: %_ < %_" % [row, rows])

  if not (column < cols):
    throw $ ValueError("Invalid Column Offset: %_ < %_" % [column, cols])

  (column * rows) + row + 1 + offset(x)

public defn min-hole-size (max-lead-diam:Double, density:DensityLevel = DensityLevelC) :
  if density == DensityLevelA :
    max-lead-diam + 0.25
  else if density == DensityLevelB :
    max-lead-diam + 0.20
  else :
    max-lead-diam + 0.15

; Pad Diameter = Minimum Hole Size + Minimum Annular Ring X 2 + Minimum Fabrication Allowance
public defn min-pad-size (min-hole-size:Double, density:DensityLevel = DensityLevelC) :
  val annular-ring-diam = 2.0 * clearance(current-rules(), MinAnnularRing)
  if density == DensityLevelA :
    min-hole-size + annular-ring-diam + 0.60
  else if density == DensityLevelB :
    min-hole-size + annular-ring-diam + 0.50
  else :
    min-hole-size + annular-ring-diam + 0.40

public defn generate-th-pad (
  pad-id:Int|Ref
  pad-gen?: ((Dims, Dims) -> Pad)|False
  min-hole-width:Double
  pos:Pose
  cls:Seqable<String> = []
) -> Maybe<VirtualPad> :
  match(pad-gen?) :
    (f:False):
      None()
    (pad-gen):
      val min-pad-width = min-pad-size(min-hole-width)
      val pad-size = Dims(min-pad-width, min-pad-width)
      val hole-size = Dims(min-hole-width, min-hole-width)
      One(VirtualPad(pad-id, pad-gen(hole-size, pad-size), pos, class = cls))
