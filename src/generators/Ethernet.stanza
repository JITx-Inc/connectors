#use-added-syntax(jitx)
defpackage connectors/generators/Ethernet :
  import core
  import collections
  import jitx
  import jitx/commands
  import jitx/shapes

  import jsl/errors
  import jsl/geometry/basics
  import jsl/geometry/box
  import jsl/geometry/LineRectangle
  import jsl/landpatterns/packages
  import jsl/landpatterns/VirtualLP
  import jsl/landpatterns/pad-planner
  import jsl/landpatterns/numbering
  import jsl/landpatterns/silkscreen
  import jsl/landpatterns/leads
  import jsl/landpatterns/quad
  import jsl/landpatterns/pads
  import jsl/landpatterns/BGA/planner

  import connectors/utils

; Information for creating a grid of pads, as commonly found on connectors
public defstruct PadGridProfile :
  center:Pose
  num-grid-pads:Int
  num-grid-rows:Int
  spacing:Dims
  lead-type:Lead
  hole-width: Dims|False
with :
  constructor => #PadGridProfile

public defn PadGridProfile (
  --
  center:Pose
  num-grid-pads:Int
  num-grid-rows:Int
  spacing:Dims
  lead-type:Lead
  hole-width: Dims|False
) :
  #PadGridProfile(
    center,
    num-grid-pads, num-grid-rows,
    spacing,
    lead-type, hole-width
  )

; Baseline information for creating a row of pads/cutouts

public defstruct LeadRowInfo :
  center:Pose
  num-cols:Int
  grid-spacing:Dims
  lead-type: Lead
  hole-width: Dims|False
    with: (default => false)
with :
  constructor => #LeadRowInfo
  printer => true

public defn LeadRowInfo (
  --
  center:Pose
  num-cols:Int
  grid-spacing:Dims
  lead-type: Lead
  hole-width: Dims|False
) :
  #LeadRowInfo(center, num-cols, grid-spacing,
    lead-type, hole-width)

public defn CutoutRowInfo (
  --
  center:Pose
  poses:Collection<Pose>
  co-shape:Shape
) :
  #CutoutRowInfo(center, poses, co-shape)

public defstruct CutoutRowInfo :
  center: Pose
  poses: Collection<Pose>
  co-shape: Shape
with :
  constructor => #CutoutRowInfo
  printer => true

doc: \<DOC>
<DOC>
public defstruct Ethernet <: Package :
  doc: \<DOC>
  Info for the main grid of leads
  <DOC>
  lead-grid-profile:PadGridProfile

  doc: \<DOC>
  Info for an arbitrary row of leads
  <DOC>
  lead-rows:Tuple<LeadRowInfo>
  doc: \<DOC>

  Info for an arbitrary row of holes
  <DOC>
  cutout-rows:Tuple<CutoutRowInfo>

  doc: \<DOC>

  Package Body for the Quad-based Package.
  <DOC>
  package-body:PackageBody with: (as-method => true)

  ; doc: \<DOC>
  ; Pad Planner

  ; This provides a default pad planner. The user can override this with their preferred
  ; shape as desired.
  ; <DOC>
  ; pad-planner:BGA-PadPlanner with: (as-method => true)

  doc: \<DOC>
  Keep-out shapes

  This provides the shape specifications for the keepout regions
  <DOC>
  keep-outs:Tuple<Shape>

  pin-1-ref:Int|Ref

with:
  printer => true
  constructor => #Ethernet

public defn Ethernet (
  --
  lead-grid-profile:PadGridProfile
  lead-rows:Tuple<LeadRowInfo>
  cutout-rows:Tuple<CutoutRowInfo>
  package-body:PackageBody
  keepouts:Tuple<Shape>
  pin-1-ref:Int|Ref = 1
):
  #Ethernet(
    lead-grid-profile,
    lead-rows, cutout-rows,
    package-body,
    keepouts,
    pin-1-ref
  )

public defmethod name (pkg:Ethernet) -> String :
  "EthernetConnector"

public defmethod courtyard-excess (pkg:Ethernet) -> Double :
  0.0

public defmethod build-silkscreen (
  pkg:Ethernet,
  vp:VirtualLP
  ) -> False:
  Ethernet-outline(pkg, vp)
  ;Ethernet-pin-1-marker(pkg, vp, pin-1-id = pin-1-ref(pkg))

public defn Ethernet-outline (
  pkg:Ethernet
  vp:VirtualLP
  --
  line-width:Double = default-silk-width(),
  mask-clearance:Double = default-mask-clearance(),
  side:Side = Top
) -> False :
  val pkg-body = package-body(pkg)
  val pkg-outline = bounds $ envelope(pkg-body, density-level = density-level(pkg))
  val pkg-outline* = fatten(line-width / 2.0, pkg-outline)
  val outline-geom = LineRectangle(pkg-outline*, line-width = line-width)

  add-artwork(vp, Silkscreen("outline", side), outline-geom, class = "outline")

; Consolidate into utility function?
public defn Ethernet-pin-1-marker (
  pkg:Ethernet,
  vp:VirtualLP
  --
  pin-1-id:Int|Ref = 1,
  line-width:Double = default-silk-width(),
  mask-clearance:Double = default-mask-clearance(),
  side:Side = Top
  ):

  val extra-margin = 0.0

  val pin-1-pad = get-pad-by-ref!(vp, pin-1-id)

  val pad-loc = pose(pin-1-pad)
  val pad-center = center(pad-loc)

  val smasks = get-layer(pin-1-pad, SolderMask(side))
  if length(smasks) == 0:
    ; This is a very strange error - it means
    ;  that pad 1 of this component doesn't have a soldermask
    ;  opening.
    ; This could happen if the user passed an erroneous `side` argument
    throw $ ValueError("Pin-1 - No Soldermask Opening for Pad on Side: %_" % [side])
  val smask = smasks[0]

  val width = x $ dims(smask)
  val offset = Point((- (width / 2.0) + mask-clearance + line-width + extra-margin), 0.0)
  val marker-shape = Circle(offset, line-width)

  val marker-geom = pad-loc * marker-shape

  add-artwork(vp, Silkscreen("pin-1-marker", side), marker-geom, name = "pin-1-dot", class = "pin1-marker")

  val outline = get-silkscreen-outline!(vp)
  val o-box = bounds(outline)

  val marker = compute-triangle-marker(pad-center, o-box, line-width)
  add-artwork(
    vp, Silkscreen("pin-1-marker", side),
    marker,
    name = "pin-1-triangle",
    class = "pin-1-marker"
    )

public defmethod build-pads (
  pkg:Ethernet,
  vp:VirtualLP,
  ) -> False :
  build-vpads(pkg, vp)
  build-cut-out(pkg, vp)

public defn build-vpads (
  pkg:Ethernet,
  vp:VirtualLP
):
  set-pose(vp, pose(package-body(pkg)))
  val grid-prof = lead-grid-profile(pkg)

  val grid-vp = create-child(vp, offset = center(grid-prof))
  val min-hole-width =
    match(hole-width(grid-prof)) :
      (d:Dims) :
        x(d)
      (f:False) :
        min-hole-size(typ $ width(lead-type(grid-prof)))
  build-staggered-grid(grid-vp, min-hole-width,
    num-grid-pads(grid-prof) * 2, num-grid-rows(grid-prof)
    spacing(grid-prof))

  ; build extra rows
  for (pad-row in lead-rows(pkg), i in 0 to false) do :
    val row-vp = create-child(vp, offset = center(pad-row))
    build-pad-row(row-vp, pad-row, num-grid-pads(grid-prof), i * num-cols(pad-row))

defn build-staggered-grid (
  vp:VirtualLP
  min-hole-width:Double
  num-pads:Int
  num-rows:Int
  pitch:Dims
):
  val planner = Staggered-Matrix-Planner(Odd-Phase)
  val num-cols = num-pads / num-rows
  val id-gen = Column-Major-Numbering(num-pads, num-cols)
  val inv-pitch = Dims(y(pitch), x(pitch))
  ; offset by y-dims to start at 0.0
  val poses = to-tuple $ seq({_ * loc(0.0, (- y(inv-pitch)))}, grid(planner, num-rows, num-cols, inv-pitch))
  val pads =
    for r in 0 to num-rows seq-cat :
      for c in 0 to num-cols seq? :
        if active?(planner, r, c) :
          val adj-c = c / 2
          generate-th-pad(to-pad-id(id-gen, r, adj-c), pth-pad{x(_0), y(_1)},
            min-hole-width, poses[r * num-cols + c],
            ["pad", to-string("row-%_ col-%_" % [r, adj-c])])
        else :
          None()
  append-all(vp, pads)

defn build-pad-row (
  vp:VirtualLP
  row-info:LeadRowInfo
  row-offset:Int = 0
  col-offset:Int = 0
):
  val num-cols = num-cols(row-info)
  val id-gen = Column-Major-Numbering(
      num-cols, num-cols,
      row-offset = row-offset,
      col-offset = col-offset,
  )
  val spacing = grid-spacing(row-info)
  val grid = grid-locs(1, num-cols, x(spacing), y(spacing))
  val min-hole-width =
      match(hole-width(row-info)) :
        (d:Dims) :
          x(d)
        (f:False) :
          min-hole-size(typ $ width(lead-type(row-info)))
  val planner = PthPadPlanner({Circle(to-radius $ min-hole-width)})
  val pads = for (pos in grid, c in 0 to false) seq? :
    val pad-id = to-pad-id(id-gen, 0, c)
    match(lead-type(row-info)):
      (th:TH-Lead):
        generate-th-pad(pad-id, th-pad-generator(planner, 0, c),
          min-hole-width, pos, ["pad", to-string("col-%_" % [c])])
      (f): None()
  append-all(vp, pads)

public defmethod build-cut-out (
  pkg:Ethernet,
  vp:VirtualLP
) -> False :
  for co-row in cutout-rows(pkg) do :
    val grid-vp = create-child(vp, offset = center(co-row))
    for p in poses(co-row) do :
      add-cutout(grid-vp, transform(p, co-shape(co-row)))

public defmethod build-keep-out (
  pkg:Ethernet,
  vp:VirtualLP,
) -> False:
  ; TODO: This can be redone once JSL supports ForbidCopper layer in VirtualLP
  inside pcb-landpattern :
    for s in keep-outs(pkg) do :
      layer(ForbidCopper(LayerIndex(0))) = pose(vp) * s