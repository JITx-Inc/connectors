#use-added-syntax(jitx)
defpackage connectors/generators/Ethernet :
  import core
  import collections
  import jitx
  import jitx/commands
  import jitx/shapes

  import jsl/design/settings
  import jsl/ensure
  import jsl/errors
  import jsl/geometry/basics
  import jsl/geometry/box
  import jsl/geometry/LineRectangle
  import jsl/landpatterns/packages
  import jsl/landpatterns/VirtualLP
  import jsl/landpatterns/pad-planner
  import jsl/landpatterns/numbering
  import jsl/landpatterns/silkscreen
  import jsl/landpatterns/leads
  import jsl/landpatterns/quad
  import jsl/landpatterns/pads
  import jsl/landpatterns/courtyard

  import connectors/utils

val PANEL-CUTOUT-WIDTH = 16.65

val JD0-0001NL-GRID-ROWS = 2
val JD0-0001NL-COLS = 5
val JD0-0001NL-EXTRA = [4]
val JD0-0001NL-GRID-PADS = JD0-0001NL-GRID-ROWS * JD0-0001NL-COLS

val JD0-0001NL-LEAD = 3.50 +/- 0.25
val JD0-0001NL-GRID-LEAD-WIDTH = 0.9 +/- 0.08
val JD0-0001NL-ROW-LEAD-WIDTH = 1.2 +/- 0.008

val JD0-0001NL-ROW-LEAD-DIAM = 1.2
val JD0-0001NL-ROW-LEAD-TOL = 0.008

val JD0-0001NL-LENGTH = 21.35
val JD0-0001NL-WIDTH = 15.90
val JD0-0001NL-HEIGHT = 13.63
val JD0-0001NL-TOL = 0.25
val JD0-0001NL-GRID-SPACING = Dims(1.27, 0.0)

val JD0-0001NL-MED-HOLE-DIAM = 1.60
val JD0-0001NL-LRG-HOLE-DIAM = 3.25

defn default-lead-types () :
  TH-Lead(
    length = JD0-0001NL-LEAD
    width = JD0-0001NL-GRID-LEAD-WIDTH
  )

defn default-pad-planner () :
  PthPadPlanner( {Circle(to-radius $ x(_))})

defn min-hole-size (max-lead-diam:Double, density:DensityLevel = DensityLevelC) :
  if density == DensityLevelA :
    max-lead-diam + 0.25
  else if density == DensityLevelB :
    max-lead-diam + 0.20
  else :
    max-lead-diam + 0.15

; Pad Diameter = Minimum Hole Size + Minimum Annular Ring X 2 + Minimum Fabrication Allowance
defn min-pad-size (min-hole-size:Double, density:DensityLevel = DensityLevelC) :
  val annular-ring-diam = 2.0 * clearance(current-rules(), MinAnnularRing)
  if density == DensityLevelA :
    min-hole-size + annular-ring-diam + 0.60
  else if density == DensityLevelB :
    min-hole-size + annular-ring-diam + 0.50
  else :
    min-hole-size + annular-ring-diam + 0.40

; Information for creating a grid of pads, as commonly found on connectors
public defstruct PadGridProfile :
  center:Pose
  num-grid-pads:Int
  num-grid-rows:Int
  spacing:Dims
  lead-type:Lead
with :
  constructor => #PadGridProfile

public defn PadGridProfile (
  --
  center:Pose
  num-grid-pads:Int
  num-grid-rows:Int
  spacing:Dims
  lead-type:Lead
) :
  #PadGridProfile(
    center,
    num-grid-pads, num-grid-rows,
    spacing,
    lead-type
  )

defn default-grid-profile () :
  PadGridProfile(
    center = loc(0.0, 8.89)
    num-grid-pads = JD0-0001NL-GRID-PADS
    num-grid-rows = JD0-0001NL-GRID-ROWS
    spacing = JD0-0001NL-GRID-SPACING
    lead-type = default-lead-types()
  )

; Baseline information for creating a row of pads/cutouts

public defstruct RowInfo :
  center: Pose
  num-cols: Int
  spacing: Dims
with :
  constructor => #RowInfo
  printer => true

public defn RowInfo (
  --
  center:Pose
  num-cols:Int
  spacing:Dims
) :
  #RowInfo(center, num-cols, spacing)

public defstruct PadRowInfo :
  row-info: RowInfo
  lead-type: Lead
  hole-width: Dims|False
    with: (default => false)

public defstruct CutoutRowInfo :
  row-info: RowInfo
  co-shape: Shape
with :
  printer => true

defn default-cutout-rows () :
 [
  ; Holes for connector shield
  CutoutRowInfo(
    RowInfo(
      center = loc(-2.14, 3.05),
      num-cols = 2,
      spacing = Dims(0.0, 0.0)
    ),
    Circle(Point(0.0, 0.0), JD0-0001NL-MED-HOLE-DIAM / 2.0)
  )
  ; Larger holes for component stabilization
  CutoutRowInfo(
    RowInfo(
      center = loc(0.0, 0.0),
      num-cols = 2,
      spacing = Dims(11.43, 0.0)
    )
    Circle(Point(0.0, 0.0), JD0-0001NL-LRG-HOLE-DIAM / 2.0)
  )
]

defn default-lead-rows () :
  [
    PadRowInfo(
      RowInfo(
        center = loc(-0.93, -4.06),
        num-cols = 2,
        spacing = Dims(1.62 + 0.93, 0.0)
      )
      TH-Lead(
        length = JD0-0001NL-LEAD
        width = JD0-0001NL-ROW-LEAD-WIDTH
      )
      Dims(1.6, 1.6)
    )
  ]

doc: \<DOC>
<DOC>
public defstruct Ethernet <: Package :
  doc: \<DOC>
  Info for the main grid of leads
  <DOC>
  lead-grid-profile:PadGridProfile

  doc: \<DOC>
  Info for an arbitrary row of leads
  <DOC>
  extra-lead-rows:Tuple<PadRowInfo>
  doc: \<DOC>

  Info for an arbitrary row of holes
  <DOC>
  extra-cutout-rows:Tuple<CutoutRowInfo>

  doc: \<DOC>

  Package Body for the Quad-based Package.
  <DOC>
  package-body:PackageBody with: (as-method => true)

  doc: \<DOC>
  Pad Planner

  This provides a default pad planner. The user can override this with their preferred
  shape as desired.
  <DOC>
  pad-planner:PadPlanner with: (as-method => true)

  doc: \<DOC>
  Keep-out shapes

  This provides the shape specifications for the keepout regions
  <DOC>
  keep-outs:Tuple<Shape>

with:
  printer => true
  constructor => #Ethernet

public defn Ethernet (
  --
  lead-grid-profile:PadGridProfile = default-grid-profile()
  extra-lead-rows:Tuple<PadRowInfo> = default-lead-rows()
  extra-cutout-rows:Tuple<CutoutRowInfo> = default-cutout-rows()
  package-body:PackageBody = default-package-body()
  pad-planner:PadPlanner = default-pad-planner()
  keep-outs:Tuple<Shape> = default-keep-outs()
):
  #Ethernet(
    lead-grid-profile,
    extra-lead-rows, extra-cutout-rows,
    package-body, pad-planner,
    keep-outs
  )

public defstruct GridWithRowsPlanner <: PadPlanner :
  rows:Int
    with : (ensure => ensure-positive!)
  cols:Int
    with : (ensure => ensure-positive!)
  extra-row-cols:Tuple<Int>

public defmethod name (pkg:Ethernet) -> String :
  "EthernetConnector"

public defn build-cutouts (
  pkg:Ethernet
  vp:VirtualLP
  --
  pose:Pose = ?
) -> False:
  inside pcb-landpattern:
    for (cutout-row in extra-cutout-rows(pkg), i in 0 to false) do :
      val ri = row-info(cutout-row)
      val [dx,dy] = [x(spacing(ri)), y(spacing(ri))]
      for pos in grid-locs(1, num-cols(ri), dx, dy) do :
        add-cutout(vp, pos, co-shape(cutout-row))

public defmethod courtyard-excess (pkg:Ethernet) -> Double :
  PANEL-CUTOUT-WIDTH - JD0-0001NL-WIDTH

public defmethod build-silkscreen (
  pkg:Ethernet,
  vp:VirtualLP
  ) -> False:
  Ethernet-outline(pkg, vp)
  Ethernet-pin-1-marker(pkg, vp)

defn default-package-body () :
  PackageBody(
    width = JD0-0001NL-WIDTH +/- JD0-0001NL-TOL
    length = JD0-0001NL-LENGTH +/- JD0-0001NL-TOL
    height = JD0-0001NL-HEIGHT +/- JD0-0001NL-TOL
    pose = loc(2.24, 0.0)
  )

public defn Ethernet-outline (
  pkg:Ethernet
  vp:VirtualLP
  --
  line-width:Double = default-silk-width(),
  mask-clearance:Double = default-mask-clearance(),
  side:Side = Top
) -> False :
  val pkg-body = package-body(pkg)
  val pkg-outline = bounds $ envelope(pkg-body, density-level = density-level(pkg))
  val pkg-outline* = fatten(line-width / 2.0, pkg-outline)
  val outline-geom = LineRectangle(pkg-outline*, line-width = line-width)

  add-artwork(vp, Silkscreen("outline", side), outline-geom, class = "outline")

public defn get-silkscreen-outline! (vp:VirtualLP) -> Shape :
  val outlines = to-tuple $ seq{as-VirtualArtwork, _} $ find-by-class(vp, "outline")
  if length(outlines) != 1:
    throw $ ValueError("Expected only one element in class 'outline': %," % [outlines])

  val outline = outlines[0]
  shape(outline)

; Consolidate into utility function?
public defn Ethernet-pin-1-marker (
  pkg:Ethernet,
  vp:VirtualLP
  --
  pin-1-id:Int|Ref = 1,
  line-width:Double = default-silk-width(),
  mask-clearance:Double = default-mask-clearance(),
  side:Side = Top
  ):

  val extra-margin = 0.0

  val pin-1-pad = get-pad-by-ref!(vp, pin-1-id)

  val pad-loc = pose(pin-1-pad)
  val pad-center = center(pad-loc)

  val smasks = get-layer(pin-1-pad, SolderMask(side))
  if length(smasks) == 0:
    ; This is a very strange error - it means
    ;  that pad 1 of this component doesn't have a soldermask
    ;  opening.
    ; This could happen if the user passed an erroneous `side` argument
    throw $ ValueError("Pin-1 - No Soldermask Opening for Pad on Side: %_" % [side])
  val smask = smasks[0]

  val width = x $ dims(smask)
  val offset = Point((- (width / 2.0) + mask-clearance + line-width + extra-margin), 0.0)
  val marker-shape = Circle(offset, line-width)

  val marker-geom = pad-loc * marker-shape

  add-artwork(vp, Silkscreen("pin-1-marker", side), marker-geom, name = "pin-1-dot", class = "pin1-marker")

  val outline = get-silkscreen-outline!(vp)
  val o-box = bounds(outline)

  val marker = compute-triangle-marker(pad-center, o-box, line-width)
  add-artwork(
    vp, Silkscreen("pin-1-marker", side),
    marker,
    name = "pin-1-triangle",
    class = "pin-1-marker"
    )

public defstruct Col-Major-Extra-Rows-Numbering <: Numbering :
  num-pads:Int with: (ensure => ensure-positive!)
  num-rows:Int with: (ensure => ensure-positive!)
  extra-row-cols:Tuple<Int>
with:
  constructor => #Col-Major-Extra-Rows-Numbering

public defn Col-Major-Extra-Rows-Numbering (
  num-pads:Int,
  num-rows:Int,
  extra-row-cols:Tuple<Int>
) -> Col-Major-Extra-Rows-Numbering :
  ensure-divisible!(num-pads, num-rows, "Col-Major-Extra-Rows-Numbering")
  #Col-Major-Extra-Rows-Numbering(num-pads, num-rows, extra-row-cols)

public defmethod to-pad-id (x:Col-Major-Extra-Rows-Numbering, row:Int, column:Int) -> Int|Ref :
  val rows = num-rows(x)
  val cols = num-pads(x) / rows

  if (row < 0 or column < 0):
    throw $ ValueError("Expecting Non-negative Indices: r=%_ c=%_" % [row,column])

  if (row >= rows):
    val extra-row-idx = row - rows
    if extra-row-idx > length(extra-row-cols(x)) - 1:
      throw $ ValueError("Invalid Row Offset: %_ < %_" % [extra-row-idx, length(extra-row-cols(x))])
    else :
      if not (column < extra-row-cols(x)[extra-row-idx]):
        throw $ ValueError("Invalid Column Offset: %_ < %_" % [column, cols])
      num-pads(x) + extra-row-idx + column + 1
  else :
    if not (column < cols):
      throw $ ValueError("Invalid Column Offset: %_ < %_" % [column, cols])
    (column * rows) + row + 1

public defmethod build-pads (
  pkg:Ethernet,
  vp:VirtualLP,
  ) -> False :
  build-vpads(pkg, vp)
  build-cutouts(pkg, vp)

public defn build-vpads (
  pkg:Ethernet,
  vp:VirtualLP
):
  val grid-prof = lead-grid-profile(pkg)

  ; Parent node is the two physical mounts, everything is relative to these
  val grid-vp = create-child(vp, offset = center(grid-prof))
  ;build-pads(pkg, sec)
  ; ; We call them rows for convenience in the definition
  ; ;  but for our grid construction - the rows are actually columns
  ; val rows = num-grid-rows(grid-prof)
  ; val cols = num-grid-pads(grid-prof) / rows
  for (pad-row in extra-lead-rows(pkg), i in 0 to false) do :
    ; val child-vp = create-child(vp, offset = center(pad-row))
    ; val ri = row-info(pad-row)
    ; val pads = for (j in 0 to num-cols(ri)) seq :
    ;   val cls = ["extra-row", to-string("row-%_" % [i]), to-string()"col-%_" % [j]]
    ;   VirtualPad(pad-id, pad-gen(pad-size), pos, class = cls)

    ; append-all(child-vp, pads)
    false
  ; ; Generate the grid
  ; val planner = pad-planner(pkg)
  ; defn gen-grid-pads () -> Seq<VirtualPad> :
  ;   val min-hole-width = min-hole-size(typ $ width(lead-type(grid-prof)))
  ;   val min-pad-width = min-pad-size(min-hole-width)

  ;   val hole-size = Dims(min-hole-width, min-hole-width)
  ;   val pad-size = Dims(min-pad-width, min-pad-width)
  ;   val s = spacing(grid-prof)
  ;   for (r in 0 to rows) seq-cat :
  ;     for (c in 0 to cols) seq?:
  ;       val pt = row-offsets(grid-prof)[r] + Point(x(s) * to-double(c), y(s) * to-double(r))
  ;       val pos = Pose(pt, 0.0, false) * center(grid-prof)
  ;       val pad-id = to-pad-id(lead-numbering(pkg), r, c)
  ;       val pad-gen? = match(lead-type(grid-prof)):
  ;         (th:TH-Lead):
  ;           val g = th-pad-generator(planner, r, c)
  ;           match(g):
  ;             (_:False): false
  ;             (func): {func(hole-size, _0)}
  ;       match(pad-gen?):
  ;         (_:False): None()
  ;         (pad-gen):
  ;           val cls = [
  ;             "pad",
  ;             to-string("col-%_" % [c]),
  ;             to-string("row-%_" % [r])
  ;           ]
  ;           One $ VirtualPad(pad-id, pad-gen(pad-size), pos, class = cls)

  ; ; Generate rows
  ; defn gen-extra-pad-rows () -> Seq<VirtualPad> :
  ;   for (lead-row in extra-lead-rows(pkg),
  ;     r in 0 to false) seq-cat :
  ;     val ri = row-info(lead-row)
  ;     val s = spacing(ri)

  ;     defn gen-pad-row-seg (start:Point, col-offset:Int, length:Int) -> Seq<VirtualPad> :
  ;       for i in 0 to length seq? :
  ;         val pt = Point(x(start) + x(s) * to-double(i), y(start) + y(s) * to-double(i))
  ;         val pos = Pose(pt, 0.0, false) * center(ri)
  ;         val col = col-offset + i
  ;         val pad-id = to-pad-id(lead-numbering(pkg), rows + r, col)
  ;         val lead-type = match(lead-types(lead-row)) :
  ;           (t:Tuple<Lead>) : t[rows * r + col]
  ;           (l:Lead) : l
  ;         val min-hole-width =
  ;           match(hole-width(lead-row)) :
  ;             (d:Dims) :
  ;               x(d)
  ;             (f:False) :
  ;               min-hole-size(typ $ width(lead-type))
  ;         val min-pad-width = min-pad-size(min-hole-width)
  ;         val hole-size = Dims(min-hole-width, min-hole-width)
  ;         val pad-size = Dims(min-pad-width, min-pad-width)

  ;         val pad-gen? = match(lead-type):
  ;           (th:TH-Lead):
  ;             val g = th-pad-generator(planner, rows + r, col)
  ;             match(g):
  ;               (_:False): false
  ;               (func): {func(hole-size, _0)}
  ;         match(pad-gen?):
  ;           (_:False): None()
  ;           (pad-gen):
  ;             val cls = [
  ;               "pad",
  ;               to-string("col-%_" % [col]),
  ;               to-string("extra-row-%_" % [rows + r])
  ;             ]
  ;             println("DEBUG %_ at pos %_" % [pad-id, pos])

  ;             One $ VirtualPad(pad-id, pad-gen(pad-size), pos, class = cls)

  ;     val pads = gen-pad-row-seg(Point(0.0,0.0), 0, num-cols(ri))
  ;     val mirror-pads = match(mirror-dims(ri)) :
  ;       (d:Dims) :
  ;         val scale = to-double $ (num-cols(ri) - 1)
  ;         val start = Point(x(d) + scale * x(s), y(d) + scale * y(s))
  ;         gen-pad-row-seg(start, num-cols(ri), num-cols(ri))
  ;       (f:False) :
  ;         []
  ;     cat(pads, mirror-pads)

  ; append-all(vp, gen-grid-pads())
  ; append-all(vp, gen-extra-pad-rows())

public defmethod build-keep-out (
  pkg:Ethernet,
  vp:VirtualLP,
) -> False:
  inside pcb-landpattern :
    for s in keep-outs(pkg) do :
      layer(ForbidCopper(LayerIndex(0), LayerIndex(0, Bottom))) = s

defn default-keep-outs () :
  val secondary-ko-width = 2.24 / 2.0
  [
    transform(loc(Point(-1.29, -10.75)), Rectangle(SW, 12.72 + 1.29, 10.75 - 8.05))
    transform(loc(Point(-2.24, 0.0)), Rectangle(SW, secondary-ko-width, 2.0))
    transform(loc(Point(13.67 - secondary-ko-width, 0.0)), Rectangle(SW, secondary-ko-width, 2.0))
  ]

