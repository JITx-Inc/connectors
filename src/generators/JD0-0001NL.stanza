#use-added-syntax(jitx)
defpackage connectors/generators/JD0-0001NL :
  import core
  import jitx
  import jitx/commands
  import jitx/shapes

  import jsl/geometry/LineRectangle
  import jsl/geometry/box
  import jsl/landpatterns/courtyard
  import jsl/landpatterns/leads
  import jsl/landpatterns/numbering
  import jsl/landpatterns/packages
  import jsl/landpatterns/pads
  import jsl/landpatterns/silkscreen
  import jsl/landpatterns/VirtualLP
  import jsl/symbols/box-symbol
  import jsl/symbols/SymbolDefn

  import connectors/utils

doc: \<DOC>
<DOC>
public defstruct JD0-0001NL <: Package :
  package-body:PackageBody
    with: (as-method => true, default => JD0-0001NL-package-body())
with:
  printer => true

public defmethod name (pkg:JD0-0001NL) -> String :
  "JD0-0001NL Ethernet Connector"

val JD0-0001NL-LENGTH = 21.35
val JD0-0001NL-WIDTH = 15.90
val JD0-0001NL-HEIGHT = 13.63
val JD0-0001NL-TOL = 0.25

defn JD0-0001NL-package-body () :
  PackageBody(
    width = JD0-0001NL-WIDTH +/- JD0-0001NL-TOL
    length = JD0-0001NL-LENGTH +/- JD0-0001NL-TOL
    height = JD0-0001NL-HEIGHT +/- JD0-0001NL-TOL
  )

defn calc-JD0-0001NL-center () :
  val half-x = JD0-0001NL-WIDTH / 2.0
  val half-y = JD0-0001NL-LENGTH / 2.0
  val center-x = 2.24 - half-x
  val center-y = 10.75 - half-y
  loc(center-x, center-y)

public defmethod build-silkscreen (
  pkg:JD0-0001NL
  vp:VirtualLP
  ) -> False:
  Ethernet-outline(pkg, vp)

public defn Ethernet-outline (
  pkg:JD0-0001NL
  vp:VirtualLP
  --
  line-width:Double = default-silk-width(),
  mask-clearance:Double = default-mask-clearance(),
  side:Side = Top
) -> False :
  val edge-vp = create-child(vp, offset = loc(-2.24, 0.0))
  val pkg-body = package-body(pkg)
  val pkg-outline = bounds $ envelope(pkg-body, density-level = density-level(pkg))
  val pkg-outline* = fatten(line-width / 2.0, pkg-outline)
  val outline-geom = LineRectangle(pkg-outline*, line-width = line-width, anchor = W)

  add-artwork(edge-vp, Silkscreen("outline", side), outline-geom, class = "outline")

public defmethod build-all (
  pkg:JD0-0001NL,
  virt:VirtualLP
  ) -> False :
  val origin = create-child(virt, offset = calc-JD0-0001NL-center())
  build-pads(pkg, origin)

  ; courtyard uses the root node
  build-courtyard(pkg, virt)
  build-silkscreen(pkg, origin)
  build-keep-out(pkg, origin)
  build-cut-out(pkg, origin)
  build-conformal-mask(pkg, origin)

; This is a workaround as the default build-courtyard doesn't play nicely
; with the pads within the scene-graph constructed here
public defmethod build-courtyard (
  pkg:JD0-0001NL,
  vp:VirtualLP,
  ) -> False:
  build-courtyard-origin(vp)
  val excess = courtyard-excess(pkg)
  val pkg-outline = bounds(envelope(package-body(pkg), density-level = density-level(pkg)))
  val outline* = fatten(excess, pkg-outline)
  val outline = LineRectangle(outline*, line-width = DEF_COURTYARD_WIDTH)
  add-artwork(vp, Courtyard(Top), outline, class = "courtyard")

public defmethod courtyard-excess (
  pkg:JD0-0001NL
) -> Double :
  ; return radius of shield mount pad so courtyard can cover it
  1.6 / 2.0

public defmethod build-keep-out (
  pkg:JD0-0001NL,
  vp:VirtualLP,
) -> False :
  val small-ko-box-width = 2.24 - 0.93
  val small-ko-box-length = 2.0
  val large-ko-box-width = 12.72 + 1.29
  val large-ko-box-length = 10.75 - 8.05
  val shapes = [
    loc(13.67, 2.0) * Rectangle(NE, small-ko-box-width, small-ko-box-length)
    loc(-0.93, 2.0) * Rectangle(NE, small-ko-box-width, small-ko-box-length)
    loc(-1.29, -8.05) * Rectangle(NW, large-ko-box-width, large-ko-box-length)
  ]
  add-keepout(vp, shapes)

public defmethod build-pads (
  pkg:JD0-0001NL,
  vp:VirtualLP,
  ) -> False :
  build-staggered-grid(pkg, vp)
  build-led-grid(pkg, vp)
  build-mounts(pkg, vp)
  build-shield(pkg, vp)

defn pth-pad-gen (min-hole-width:Double) :
  val min-pad-width = min-pad-size(min-hole-width)
  pth-pad(min-hole-width, min-pad-width)

defn npth-pad-gen (min-hole-width:Double) :
  npth-pad(Circle(min-hole-width / 2.0))

defn create-pads (
  num-rows:Int
  num-cols:Int
  pitch:Point
  min-hole-width:Double
  phase-offset:Pose = loc(0.0, 0.0)
  id-offset:Int = 0
  pad-gen: (Double -> Pad) = pth-pad-gen
) :
  val pad-def = pad-gen(min-hole-width)

  val row-offset = id-offset / num-rows
  val col-offset = id-offset % num-rows
  val num-pads = num-rows * num-cols

  val id-gen = Column-Major-Numbering(num-pads, num-cols,
    row-offset = row-offset, col-offset = col-offset)
  val poses = to-seq $ grid-locs(
      NW, num-rows, num-cols, x(pitch), y(pitch), NW, true)

  for r in 0 to num-rows seq-cat :
    val row-offset = loc(0.0, 0.0) when r % 2 == 0 else phase-offset
    for c in 0 to num-cols seq :
      VirtualPad(to-pad-id(id-gen, r, c)
        pad-def, row-offset * next(poses),
        class = ["pad", to-string("row-%_ col-%_" % [r, c])])

defn build-staggered-grid (
  pkg:JD0-0001NL
  vp:VirtualLP
):
  val origin = create-child(vp, offset = loc(0.0, 8.89))
  val pads = create-pads(2, 5, Point(2.54, 8.9 - 6.35), 0.9, loc(1.27, 0.0))
  append-all(origin, pads)

defn build-led-grid (
  pkg:JD0-0001NL
  vp:VirtualLP
):
  val led-offset = 10
  val led-pitch = Point(0.93 + 1.62, 0.0)
  val grn-led = create-child(vp, offset = loc(-0.93, -4.06))
  append-all(grn-led,
    create-pads(1, 2, led-pitch, 1.2, loc(0.0, 0.0), led-offset))

  val ylw-led = create-child(vp, offset = loc(9.82, -4.06))
  append-all(ylw-led,
    create-pads(1, 2, led-pitch, 1.2, loc(0.0, 0.0), led-offset + 2))

defn build-shield (
  pkg:JD0-0001NL
  vp:VirtualLP
):
  val pitch = Point(2.14 + 13.57, 0.0)
  val id-offset = 14
  val origin = create-child(vp, offset = loc(-2.14, 3.05))
  append-all(origin,
    create-pads(1, 2, pitch, 1.6, loc(0.0, 0.0), id-offset, npth-pad-gen))

defn build-mounts (
  pkg:JD0-0001NL
  vp:VirtualLP
):
  val pitch = Point(11.43, 0.0)
  val id-offset = 16
  append-all(vp
    create-pads(1, 2, pitch, 3.25, loc(0.0, 0.0), id-offset, npth-pad-gen))